/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// main.ts
__export(exports, {
  default: () => ObsidianToQuartoPlugin
});
var import_obsidian = __toModule(require("obsidian"));
var path = __toModule(require("path"));
var fs = __toModule(require("fs"));
var DEFAULT_SETTINGS = {
  dateOption: "none",
  dateFormat: "YYYY-MM-DD",
  outputFolder: "",
  overwriteExisting: false,
  importTags: true,
  allowExternalPaths: false
};
var ObsidianToQuartoPlugin = class extends import_obsidian.Plugin {
  async onload() {
    console.log("Loading ObsidianToQuartoPlugin");
    await this.loadSettings();
    this.addCommand({
      id: "export-to-quarto",
      name: "Export to Quarto QMD",
      callback: () => this.exportToQuarto()
    });
    this.addSettingTab(new ObsidianToQuartoSettingTab(this.app, this));
    console.log("ObsidianToQuartoPlugin loaded");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async exportToQuarto() {
    try {
      const activeFile = this.app.workspace.getActiveFile();
      if (!activeFile || activeFile.extension !== "md") {
        new import_obsidian.Notice("Please open a Markdown file before exporting");
        return;
      }
      const content = await this.app.vault.read(activeFile);
      const convertedContent = await this.convertToQuarto(content, activeFile);
      let outputPath;
      let newFileName = activeFile.basename + ".qmd";
      let newPath;
      if (this.settings.allowExternalPaths && path.isAbsolute(this.settings.outputFolder)) {
        outputPath = this.settings.outputFolder;
        try {
          fs.mkdirSync(outputPath, { recursive: true });
          newPath = path.join(outputPath, newFileName);
          if (fs.existsSync(newPath)) {
            if (this.settings.overwriteExisting) {
              fs.unlinkSync(newPath);
            } else {
              let counter = 1;
              while (fs.existsSync(newPath)) {
                newFileName = `${activeFile.basename}_${counter}.qmd`;
                newPath = path.join(outputPath, newFileName);
                counter++;
              }
            }
          }
          fs.writeFileSync(newPath, convertedContent);
          new import_obsidian.Notice(`Successfully exported to ${newPath}`);
        } catch (error) {
          console.error("Error writing to external path:", error);
          new import_obsidian.Notice(`Failed to write to external path: ${error.message}`);
          return;
        }
      } else {
        outputPath = this.settings.outputFolder || activeFile.parent.path;
        await this.app.vault.adapter.mkdir(outputPath);
        newPath = `${outputPath}/${newFileName}`;
        if (await this.app.vault.adapter.exists(newPath)) {
          if (this.settings.overwriteExisting) {
            await this.app.vault.adapter.remove(newPath);
          } else {
            let counter = 1;
            while (await this.app.vault.adapter.exists(newPath)) {
              newFileName = `${activeFile.basename}_${counter}.qmd`;
              newPath = `${outputPath}/${newFileName}`;
              counter++;
            }
          }
        }
        await this.app.vault.create(newPath, convertedContent);
        const newFile = this.app.vault.getAbstractFileByPath(newPath);
        if (newFile instanceof import_obsidian.TFile) {
          await this.app.workspace.openLinkText(newFile.path, "", true);
        }
        new import_obsidian.Notice(`Successfully exported to ${newFileName}`);
      }
    } catch (error) {
      console.error("Error in exportToQuarto:", error);
      new import_obsidian.Notice("Failed to export to Quarto QMD. Check console for details.");
    }
  }
  convertObsidianImages(content) {
    return content.replace(/!\[\[([^\]]+?)\]\]/g, "![]($1)");
  }
  async convertToQuarto(content, file) {
    let frontmatter = "";
    let mainContent = content;
    const frontmatterMatch = content.match(/^---\n[\s\S]*?\n---\n/);
    if (frontmatterMatch) {
      frontmatter = frontmatterMatch[0];
      mainContent = content.slice(frontmatter.length);
    }
    const title = file.basename;
    let newFrontmatter = `---
title: "${title}"
`;
    if (this.settings.dateOption !== "none") {
      const date = await this.getFileDate(file);
      newFrontmatter += `date: "${date}"
`;
    }
    if (this.settings.importTags) {
      const fileTags = this.getFileTags(file);
      if (fileTags.length > 0) {
        newFrontmatter += `tags:
${fileTags.map((tag) => `  - ${tag}`).join("\n")}
`;
      }
    }
    if (frontmatter) {
      const existingFrontmatter = frontmatter.slice(4, -4).split("\n").filter((line) => !line.startsWith("tags:") && !line.trim().startsWith("-")).join("\n");
      newFrontmatter += existingFrontmatter + "\n";
    }
    newFrontmatter += "---\n\n";
    let convertedContent = mainContent;
    const firstHeaderIndex = convertedContent.search(/^\s*#/m);
    let preHeaderContent = "";
    if (firstHeaderIndex !== -1) {
      preHeaderContent = convertedContent.slice(0, firstHeaderIndex).trim() + "\n\n";
      convertedContent = convertedContent.slice(firstHeaderIndex);
    }
    convertedContent = this.convertObsidianImages(convertedContent);
    convertedContent = await this.convertEmbeddedNotes(convertedContent);
    convertedContent = convertedContent.replace(/^(#+\s.*)/gm, "\n$1");
    convertedContent = convertedContent.replace(/> \[!(\w+)\](.*?)\n((?:>.*\n?)*)/g, (_, type, title2, content2) => {
      const quartoType = this.mapCalloutType(type);
      return `::: {.callout-${quartoType}}
${title2.trim() ? `## ${title2.trim()}
` : ""}${content2.replace(/^>/gm, "").trim()}
:::

`;
    });
    return newFrontmatter + preHeaderContent + convertedContent;
  }
  getFileTags(file) {
    const fileCache = this.app.metadataCache.getFileCache(file);
    if (fileCache) {
      const tags = (0, import_obsidian.getAllTags)(fileCache);
      return tags ? tags.map((tag) => tag.replace("#", "")) : [];
    }
    return [];
  }
  async getFileDate(file) {
    try {
      const stat = await this.app.vault.adapter.stat(file.path);
      if (!stat) {
        console.error("Failed to get file stats");
        return this.formatDate(new Date());
      }
      const date = this.settings.dateOption === "created" ? stat.ctime : stat.mtime;
      return this.formatDate(new Date(date));
    } catch (error) {
      console.error("Error getting file date:", error);
      return this.formatDate(new Date());
    }
  }
  formatDate(date) {
    const format = this.settings.dateFormat;
    return format.replace("YYYY", date.getFullYear().toString()).replace("MM", (date.getMonth() + 1).toString().padStart(2, "0")).replace("DD", date.getDate().toString().padStart(2, "0")).replace("HH", date.getHours().toString().padStart(2, "0")).replace("mm", date.getMinutes().toString().padStart(2, "0")).replace("ss", date.getSeconds().toString().padStart(2, "0"));
  }
  async convertEmbeddedNotes(content) {
    const embeddedNoteRegex = /!\[\[([^\]]+?)((?:#|\^).+?)?\]\]/g;
    const embedPromises = [];
    content.replace(embeddedNoteRegex, (match, noteName, reference) => {
      embedPromises.push(this.getEmbeddedNoteContent(noteName, reference));
      return match;
    });
    const embeddedContents = await Promise.all(embedPromises);
    return content.replace(embeddedNoteRegex, () => embeddedContents.shift() || "");
  }
  async getEmbeddedNoteContent(noteName, reference) {
    const file = this.app.metadataCache.getFirstLinkpathDest(noteName, "");
    if (file instanceof import_obsidian.TFile) {
      let content = await this.app.vault.read(file);
      console.log(`Original content length: ${content.length}`);
      if (reference) {
        console.log(`Processing reference: ${reference}`);
        if (reference.startsWith("#")) {
          const headerName = reference.slice(1);
          console.log(`Looking for header: ${headerName}`);
          const headerRegex = new RegExp(`^(#+)\\s*${this.escapeRegExp(headerName)}\\s*$`, "im");
          const headerMatch = content.match(headerRegex);
          if (headerMatch) {
            console.log(`Found header: ${headerMatch[0]}`);
            const headerLevel = headerMatch[1].length;
            const headerIndex = headerMatch.index;
            const nextHeaderRegex = new RegExp(`^#{1,${headerLevel}}\\s`, "im");
            const remainingContent = content.slice(headerIndex + headerMatch[0].length);
            const nextHeaderMatch = remainingContent.match(nextHeaderRegex);
            const nextHeaderIndex = nextHeaderMatch ? nextHeaderMatch.index + headerMatch[0].length : content.length;
            content = content.slice(headerIndex, headerIndex + nextHeaderIndex);
            console.log(`Extracted content length: ${content.length}`);
          } else {
            console.log(`Header not found: ${headerName}`);
            return `

> [!warning] Header not found: ${headerName} in ${noteName}

`;
          }
        } else if (reference.startsWith("^")) {
          const blockId = reference.slice(1);
          console.log(`Looking for block: ${blockId}`);
          const blockRegex = new RegExp(`(^|
)([^
]+\\s*(?:{{[^}]*}})?\\s*\\^${this.escapeRegExp(blockId)}\\s*$)`, "m");
          const blockMatch = content.match(blockRegex);
          if (blockMatch) {
            console.log(`Found block: ${blockMatch[2]}`);
            const blockIndex = blockMatch.index + blockMatch[1].length;
            const blockEndIndex = content.indexOf("\n\n", blockIndex);
            content = blockEndIndex !== -1 ? content.slice(blockIndex, blockEndIndex).trim() : content.slice(blockIndex).trim();
            console.log(`Extracted content length: ${content.length}`);
          } else {
            console.log(`Block not found: ${blockId}`);
            return `

> [!warning] Block not found: ${blockId} in ${noteName}

`;
          }
        }
      }
      content = content.replace(/\s*\^[a-zA-Z0-9-]+\s*$/, "");
      return `

${content.trim()}

`;
    } else {
      console.log(`File not found: ${noteName}`);
      return `

> [!warning] Embedded note not found: ${noteName}${reference || ""}

`;
    }
  }
  escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  mapCalloutType(obsidianType) {
    const typeMap = {
      "note": "note",
      "info": "info",
      "tip": "tip",
      "success": "success",
      "question": "question",
      "warning": "warning",
      "failure": "error",
      "danger": "warning",
      "bug": "bug",
      "example": "example",
      "quote": "quote"
    };
    return typeMap[obsidianType.toLowerCase()] || "note";
  }
  slugify(text) {
    return text.toLowerCase().replace(/[^\w ]+/g, "").replace(/ +/g, "-");
  }
};
var ObsidianToQuartoSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Allow External Paths").setDesc("If enabled, allows exporting files to locations outside the Obsidian vault using absolute paths").addToggle((toggle) => toggle.setValue(this.plugin.settings.allowExternalPaths).onChange(async (value) => {
      this.plugin.settings.allowExternalPaths = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Output Folder").setDesc("Specify the folder where QMD files should be saved. Use absolute path (e.g., /home/user/exports) to save outside vault, or relative path for inside vault. Leave blank to use same folder as original file.").addText((text) => text.setPlaceholder("Enter folder path").setValue(this.plugin.settings.outputFolder).onChange(async (value) => {
      this.plugin.settings.outputFolder = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Date Option").setDesc("Choose which date to add to the Quarto document").addDropdown((dropdown) => dropdown.addOption("none", "No date").addOption("created", "Creation date").addOption("modified", "Last modified date").setValue(this.plugin.settings.dateOption).onChange(async (value) => {
      this.plugin.settings.dateOption = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Date Format").setDesc("Specify the date format (YYYY: year, MM: month, DD: day, HH: hour, mm: minute, ss: second)").addText((text) => text.setPlaceholder("YYYY-MM-DD").setValue(this.plugin.settings.dateFormat).onChange(async (value) => {
      this.plugin.settings.dateFormat = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Overwrite Existing Files").setDesc("If checked, existing files will be overwritten. If unchecked, a new file with a number appended will be created.").addToggle((toggle) => toggle.setValue(this.plugin.settings.overwriteExisting).onChange(async (value) => {
      this.plugin.settings.overwriteExisting = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Import Tags").setDesc("If checked, tags from the Obsidian note will be imported into the Quarto file.").addToggle((toggle) => toggle.setValue(this.plugin.settings.importTags).onChange(async (value) => {
      this.plugin.settings.importTags = value;
      await this.plugin.saveSettings();
    }));
  }
};

/* nosourcemap */