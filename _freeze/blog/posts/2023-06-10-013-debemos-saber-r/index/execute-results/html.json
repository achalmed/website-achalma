{
  "hash": "c826c7ef6d217bf630ddedc88496e96b",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Lo que debemos saber de R\nsubtitle: Explorando las capacidades de R y su uso en el entorno Linux\ndescription: |\n  Descubre cómo comenzar con R en el sistema operativo Linux, desde la descarga e instalación hasta la manipulación de datos para análisis. Aprende sobre las funcionalidades y ventajas que ofrece este software en el entorno Linux.\ncategories:\n  - R\n  - RStudio\ntags:\n  - R\n  - RStudio\n  - Linux\n  - ManipulaciónDeDatos\n  - AnálisisDeDatos\ncitation:\n  pdf-url: https://achalmaedison.netlify.app/docs/blog/posts/2023-06-10-3-debemos-saber-r/index.pdf\ndate: \"06/11/2023\"\ndraft: false  # Modo de borrador (false = final, true = borrador)\n---\n\n\n\n\n\n\n# Lo que debemos saber\n\n## Tipos de datos\n\nEn R, es fundamental comprender los diferentes tipos de datos disponibles. A continuación, exploraremos los tres tipos básicos de datos en R y cómo se utilizan en la programación.\n\n### 1. Tipos de datos numéricos\n\nLos datos numéricos en R se dividen en dos tipos principales:\n\na.  Números reales, se conoce como `double`. Estos son los números más comunes y se utilizan para representar valores decimales. Por ejemplo, 3.14 y 2.71828 son números reales en R. La precisión de los números reales en R depende de la máquina en la que se ejecuta el programa.\n\nb.  Números enteros, se conoce como `integer`. Estos son números que no contienen decimales y se utilizan para representar valores enteros. Por ejemplo, 1, 2, -5 son ejemplos de números enteros en R. Los números enteros se utilizan cuando no se requiere precisión decimal.\n\n### 2. Tipo de datos lógico\n\nEl tipo de dato lógico en R se conoce como `booleano`. Este tipo de dato puede tener uno de dos valores: TRUE o FALSE. Los valores booleanos se utilizan principalmente para realizar operaciones de comparación y evaluación lógica en los programas. Por ejemplo, se puede usar una expresión lógica para verificar si una condición es verdadera o falsa.\n\n### 3. Tipo de datos carácter\n\nEl tipo de dato carácter en R se utiliza para almacenar letras `text` y símbolos `strings`. Los datos de tipo carácter se definen utilizando comillas simples ('') o comillas dobles (\"\"). Por ejemplo,\"Hola\" y 'RStudio' son ejemplos de datos de tipo carácter en R. Los datos de tipo carácter se utilizan con frecuencia para almacenar texto legible por humanos, como nombres, descripciones o mensajes.\n\n> Es importante comprender estos tipos de datos en R, ya que nos permiten manipular y realizar operaciones en los datos de manera adecuada. Cada tipo de dato tiene sus propias características y funciones asociadas que nos permiten realizar tareas específicas en la programación.\n\n## Estructura de datos\n\nLas estructuras de datos nos permiten organizar y manipular la información de manera eficiente. A continuación, exploraremos las principales estructuras de datos disponibles en R y cómo se utilizan en la programación.\n\n### 1. Escalar\n\nUn escalar es un dato individual, como un número o una palabra, que no está agrupado con otros elementos. En R, los escalares pueden ser de diferentes tipos de datos, como numéricos, lógicos o caracteres. Estos datos se utilizan cuando solo necesitamos almacenar una única observación.\n\n### 2. Vector\n\nUn vector es una colección ordenada de elementos del mismo tipo de dato. Puede contener números, valores lógicos o caracteres. En R, los vectores son utilizados para almacenar conjuntos de datos relacionados. Por ejemplo, podemos tener un vector de edades o un vector de nombres. Los vectores son una de las estructuras de datos más utilizadas en R y nos permiten realizar operaciones y cálculos de manera eficiente.\n\n**Vectores**\n\nConcatenación de elementos con **`c()`**: Se utiliza la función `c()` para concatenar elementos y crear vectores en R.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(0.5, 0.6, 0.25) # números decimales (double)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.50 0.60 0.25\n```\n\n\n:::\n\n```{.r .cell-code}\nc(9L, 10L, 11L, 12L, 13L) # números enteros (integer)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  9 10 11 12 13\n```\n\n\n:::\n\n```{.r .cell-code}\nc(9:13) # secuencia de números enteros (integer sequence)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  9 10 11 12 13\n```\n\n\n:::\n\n```{.r .cell-code}\nc(TRUE, FALSE, FALSE) # valores lógicos (logical)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nc(1 + 0i, 2 + 4i) # números complejos (complex)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1+0i 2+4i\n```\n\n\n:::\n\n```{.r .cell-code}\nc(\"a\", \"b\", \"c\") # caracteres (character)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"a\" \"b\" \"c\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\n**Acciones con vectores**\n\n1.  Asignar los vectores a nombres:\n\n    Creamos un vector llamado \"dbl\" que contiene los números decimales 0.5, 0.6 y 0.25.\n\n\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    dbl <- c(0.5, 0.6, 0.25)\n    ```\n    :::\n\n\n\n\n\n\n    Creamos un vector llamado \"chr\" que contiene los caracteres \"a\", \"b\" y \"c\".\n\n\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    chr <- c(\"a\", \"b\", \"c\")\n    ```\n    :::\n\n\n\n\n\n\n2.  Imprimir los vectores \"dbl\" y \"chr\" en la consola:\n\n    Visualizamos en la consola el contenido del vector \"dbl\", que son los números decimales 0.5, 0.6 y 0.25.\n\n\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    dbl\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 0.50 0.60 0.25\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n\n\n    Visualizamos en la consola el contenido del vector \"chr\", que son los caracteres \"a\", \"b\" y \"c\".\n\n\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    chr\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"a\" \"b\" \"c\"\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n\n\n3.  Verificar el número de elementos en \"dbl\" y \"chr\":\n\n    Calculamos y mostramos en la consola la longitud del vector \"dbl\", que es 3.\n\n\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    length(dbl)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 3\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n\n\n    Calculamos y mostramos en la consola la longitud del vector \"chr\", que es 3.\n\n\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    length(chr)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 3\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n\n\n4.  Verificar el tipo de dato de \"dbl\" y \"chr\":\n\n    Visualizamos en la consola el tipo de dato del vector \"dbl\", que es \"double\" (números decimales).\n\n\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    typeof(dbl)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"double\"\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n\n\n    Visualizamos en la consola el tipo de dato del vector \"chr\", que es \"character\" (caracteres).\n\n\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    typeof(chr)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"character\"\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n\n\n5.  Combinar dos vectores:\n\n    Se puede combinar el vector \"dbl\" consigo mismo utilizando la función \"c()\", creando un nuevo vector que contiene los elementos duplicados del vector original.\n\n\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    c(dbl, dbl)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 0.50 0.60 0.25 0.50 0.60 0.25\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n\n\n    Tambien se puede combina el vector \"dbl\" con el vector \"chr\" utilizando la función \"c()\", creando un nuevo vector que contiene los elementos de ambos vectores concatenados.\n\n\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    c(dbl, chr)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"0.5\"  \"0.6\"  \"0.25\" \"a\"    \"b\"    \"c\"   \n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n\n\n::: callout-note\nEl cambio automático del tipo de datos del vector resultante se denomina coerción. La coerción garantiza que se mantiene el mismo tipo de datos para cada elemento del vector.\n:::\n\n**Operaciones aritméticas con vectores**\n\n1.  Definamos dos nuevos vectores numéricos llamados `a` y `b` con 4 elementos cada uno:\n\n\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    a <- c(1, 2, 3, 4)\n    b <- c(10, 20, 30, 40)\n    ```\n    :::\n\n\n\n\n\n\n2.  Realizamos una multiplicación escalar de `a` por 5, lo que significa que cada elemento en `a` se multiplica por 5:\n\n\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    a * 5\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1]  5 10 15 20\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n\n\n3.  Realizamos una multiplicación de vectores entre `a` y `b`, lo que implica multiplicar cada elemento en `a` por el elemento correspondiente en `b`:\n\n\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    a * b\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1]  10  40  90 160\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n\n\n4.  Creamos un nuevo vector numérico llamado `v` con longitud 5.\n\n\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    v <- c(1.1, 1.2, 1.3, 1.4, 1.5)\n    a * v\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 1.1 2.4 3.9 5.6 1.5\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n\n\n::: callout-note\nLas operaciones aritméticas de los vectores se realizan por elementos. si dos vectores no tienen la misma longitud, el vector más corto se reciclará para que coincida con el más largo (en este caso, se vuelve a utilizar el primer elemento de a).\n:::\n\n### 3. Matriz\n\nUna matriz es una estructura bidimensional que contiene elementos organizados en filas y columnas. Todos los elementos de una matriz deben ser del mismo tipo de dato. Las matrices son útiles para almacenar datos tabulares, como una tabla de datos con variables en filas y observaciones en columnas. En R, podemos realizar operaciones matriciales y manipular los datos de manera eficiente utilizando esta estructura.\n\n**Matrices**\n\n1.  Combinamos los vectores `a` y `b`, definidas anteriormente, por columnas utilizando la función `cbind()`:\n\n\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    A <- cbind(a, b)\n    A\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n         a  b\n    [1,] 1 10\n    [2,] 2 20\n    [3,] 3 30\n    [4,] 4 40\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n\n\n    Esta opción combina los vectores `a` y `b` por columnas, creando una matriz `A` donde los elementos de `a` forman la primera columna y los elementos de `b` forman la segunda columna.\n\n2.  Combinamos los vectores `a` y `b` por filas utilizando la función `rbind()`:\n\n\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    B <- rbind(a, b)\n    B\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n      [,1] [,2] [,3] [,4]\n    a    1    2    3    4\n    b   10   20   30   40\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n\n\n    En esta opción, los vectores `a` y `b` se combinan por filas para crear una matriz `B`. Los elementos de `a` forman la primera fila y los elementos de `b` forman la segunda fila.\n\n3.  Creamos una matriz a partir de los elementos de vector `a` utilizando la función `matrix()`:\n\n\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    A <- matrix(a, ncol = 2, nrow = 2)\n    A\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n         [,1] [,2]\n    [1,]    1    3\n    [2,]    2    4\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n\n\n    Aquí se utiliza la función `matrix()` para crear una matriz `A` a partir de los elementos del vector `a`. Se especifica que la matriz tendrá 2 columnas y 2 filas. Los argumentos nrow y ncol indican el número de filas y el número de columnas de que consta la matriz resultante.\n\n4.  Para 4 elementos y ncol =2 la matriz sólo puede tener 2 filas. Por lo tanto no es necesario especificar ambos argumentos\n\n\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    A <- matrix(a, ncol = 2)\n    A\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n         [,1] [,2]\n    [1,]    1    3\n    [2,]    2    4\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n\n\n    En esta variante, se crea una matriz `A` con 2 columnas y se ajusta automáticamente el número de filas según la longitud del vector `a`.\n\n5.  Por defecto la matriz se rellena columna a columna (R trata internamente un objeto matriz como vector columna). si la matriz debe rellenarse fila a fila se requiere el argumento `byrow = TRUE`\n\n\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    B <- matrix(a, ncol = 2, byrow = TRUE)\n    B\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n         [,1] [,2]\n    [1,]    1    2\n    [2,]    3    4\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n\n\n    En esta opción, se crea una matriz `B` con 2 columnas y se especifica que los elementos del vector `a` se distribuirán por filas `byrow = TRUE`, es decir, los primeros elementos de `a` formarán la primera fila, los siguientes elementos formarán la segunda fila, y así sucesivamente.\n\n**Acciones con matrices**\n\n1.  Verificamos el número de filas de la matriz `A` utilizando la función `nrow()`:\n\n\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    nrow(A)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 2\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n\n\n    Esta línea de código devuelve el número de filas de la matriz `A`.\n\n2.  Verificamos el número de columnas de la matriz `A` utilizando la función `ncol()`:\n\n\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    ncol(A)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 2\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n\n\n    Aquí se obtiene el número de columnas de la matriz `A`.\n\n3.  Verificamos la dimensión (número de filas y columnas) de la matriz `A` utilizando la función `dim()`:\n\n\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    dim(A)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 2 2\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n\n\n    Esta línea de código devuelve la dimensión de la matriz `A` en formato `[nrow, ncol]`.\n\n4.  Combinamos dos matrices `A` por columnas utilizando la función `cbind()` y almacenamos el resultado en `D.wide`:\n\n\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    D.wide <- cbind(A, A)\n    D.wide\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n         [,1] [,2] [,3] [,4]\n    [1,]    1    3    1    3\n    [2,]    2    4    2    4\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n\n\n    En esta línea se crea una nueva matriz `D.wide` que combina las matrices `A` y `A` por columnas.\n\n5.  Combinamos dos matrices `A` por filas utilizando la función `rbind()` y almacenamos el resultado en `D.long`:\n\n\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    D.long <- rbind(A, A)\n    D.long\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n         [,1] [,2]\n    [1,]    1    3\n    [2,]    2    4\n    [3,]    1    3\n    [4,]    2    4\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n\n\n    Aquí se crea una nueva matriz `D.long` que combina las matrices `A` y `A` por filas.\n\n6.  Combinamos las matrices `D.wide` y `D.long` por columnas utilizando la función `cbind()` y almacenamos el resultado en `D`:\n\n\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    # D <- cbind(D.wide, D.long)\n    ```\n    :::\n\n\n\n\n\n\n    En esta línea se crea una nueva matriz `D` que combina las matrices `D.wide` y `D.long` por columnas.\n\n**Operaciones aritméticas con matrices**\n\n1.  Suma de la matriz `B` consigo misma utilizando el operador `+`:\n\n\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    B + B\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n         [,1] [,2]\n    [1,]    2    4\n    [2,]    6    8\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n\n\n    Esta línea de código realiza la suma de la matriz `B` con ella misma.\n\n2.  Multiplicación escalar de la matriz `B` por 2 utilizando el operador `*`:\n\n\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    B * 2\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n         [,1] [,2]\n    [1,]    2    4\n    [2,]    6    8\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n\n\n    Aquí se realiza la multiplicación de cada elemento de la matriz `B` por 2.\n\n3.  Multiplicación elemento a elemento de la matriz `B` consigo misma y almacenar el resultado en `a`:\n\n\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    a <- B * B\n    a\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n         [,1] [,2]\n    [1,]    1    4\n    [2,]    9   16\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n\n\n    En esta línea se realiza la multiplicación elemento a elemento de la matriz `B` con ella misma, y el resultado se almacena en la matriz `a`.\n\n4.  Multiplicación de matrices utilizando el operador `%*%`:\n\n\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    C <- B %*% B\n    C\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n         [,1] [,2]\n    [1,]    7   10\n    [2,]   15   22\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n\n\n    Aquí se realiza la multiplicación de matrices entre la matriz `B` y ella misma, y el resultado se almacena en la matriz `C`.\n\n**Otras operaciones con matrices:**\n\n1.  Transposición de la matriz `D.wide` utilizando la función `t()`:\n\n\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    t(D.wide)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n         [,1] [,2]\n    [1,]    1    2\n    [2,]    3    4\n    [3,]    1    2\n    [4,]    3    4\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n\n\n    Esta línea de código transpone la matriz `D.wide`, es decir, intercambia las filas por columnas y viceversa.\n\n2.  Cálculo del determinante de la matriz `B` utilizando la función `det()`:\n\n\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    det(B)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] -2\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n\n\n    Aquí se calcula el determinante de la matriz `B`.\n\n3.  Cálculo de la inversa de la matriz `B` utilizando la función `solve()` (solo si el determinante es diferente de 0):\n\n\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    solve(B)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n         [,1] [,2]\n    [1,] -2.0  1.0\n    [2,]  1.5 -0.5\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n\n\n    En esta línea se calcula la inversa de la matriz `B`, siempre y cuando el determinante sea diferente de 0.\n\n4.  Cálculo de los valores propios (eigenvalues) de una matriz cuadrada y simétrica utilizando la función `eigen()`:\n\n\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    eigen(B)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    eigen() decomposition\n    $values\n    [1]  5.3722813 -0.3722813\n    \n    $vectors\n               [,1]       [,2]\n    [1,] -0.4159736 -0.8245648\n    [2,] -0.9093767  0.5657675\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n\n\n    Aquí se calculan los valores propios de la matriz `B`. Esta operación solo es aplicable a matrices cuadradas y simétricas.\n\n### 4. Data frame\n\nUn data frame es una estructura similar a una matriz, pero más flexible. Puede contener columnas con diferentes tipos de datos, lo que lo hace ideal para almacenar conjuntos de datos heterogéneos. Los data frames son muy utilizados en el análisis de datos, ya que nos permiten manipular y explorar datos de manera eficiente. Podemos realizar operaciones de filtrado, selección y transformación en los data frames para obtener información significativa.\n\n**Creación del data frame:**\n\n1.  Creamos vectores con diferentes tipos de datos, como números decimales (`dbl`), números enteros (`int`), valores lógicos (`lgl`) y caracteres (`chr`):\n\n\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    dbl <- c(0.5, 0.6, 0.25, 1.2, 0.333) # números decimales (double)\n    int <- c(9L, 10L, 11L, 12L, 13L) # números enteros (integer)\n    lgl <- c(TRUE, FALSE, FALSE, TRUE, TRUE) # valores lógicos (logical)\n    chr <- c(\"a\", \"b\", \"c\", \"d\", \"e\") # caracteres (character)\n    ```\n    :::\n\n\n\n\n\n\n    Cada vector tiene elementos que representan valores de su respectivo tipo de dato.\n\n2.  Utilizamos la función `data.frame()` para combinar los vectores en un data frame llamado `df`:\n\n\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    df <- data.frame(dbl, int, lgl, chr)\n    ```\n    :::\n\n\n\n\n\n\n    El data frame `df` se crea utilizando los vectores `dbl`, `int`, `lgl` y `chr` como columnas.\n\n3.  Mostamos el contenido del data frame en la consola:\n\n\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    df\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n        dbl int   lgl chr\n    1 0.500   9  TRUE   a\n    2 0.600  10 FALSE   b\n    3 0.250  11 FALSE   c\n    4 1.200  12  TRUE   d\n    5 0.333  13  TRUE   e\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n\n\n    Esto imprime el contenido del data frame `df`.\n\n**Acciones con data frames:**\n\n1.  Verificamos el número de filas del data frame utilizando la función `nrow()`:\n\n\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    nrow(df)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 5\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n\n\n    Esta línea de código devuelve el número de filas en el data frame `df`.\n\n2.  Verificamos el número de columnas del data frame utilizando la función `ncol()`:\n\n\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    ncol(df)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 4\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n\n\n    Aquí se obtiene el número de columnas en el data frame `df`.\n\n3.  Verificamos la dimensión (número de filas y columnas) del data frame utilizando la función `dim()`:\n\n\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    dim(df)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 5 4\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n\n\n    Esta línea de código devuelve la dimensión del data frame `df` en formato `[nrow, ncol]`, es decir, el número de filas y columnas que tiene el data frame.\n\n### 5. Lista\n\nUna lista es una estructura de datos genérica que puede contener diferentes objetos, como vectores, matrices, data frames o incluso otras listas. A diferencia de las otras estructuras, las listas no tienen restricciones en cuanto a los tipos de datos o la longitud de los componentes individuales. Las listas son muy flexibles y se utilizan cuando necesitamos almacenar objetos de diferentes tipos o estructuras complejas.\n\n**Creación de la lista**\n\n1.  Creamos una variable `a` que contiene un **escalar** de tipo entero (`1L`):\n\n\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    a <- 1L\n    ```\n    :::\n\n\n\n\n\n\n2.  Creamos un **vector numérico** `dbl` con 5 elementos:\n\n\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    dbl <- c(0.5, 0.6, 0.25, 1.2, 0.333)\n    ```\n    :::\n\n\n\n\n\n\n3.  Creamos un **vector de caracteres** `chr` con 3 elementos:\n\n\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    chr <- c(\"a\", \"b\", \"c\")\n    ```\n    :::\n\n\n\n\n\n\n4.  Creamos un vector `v` con 4 elementos de tipo numérico:\n\n\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    v <- c(1.1, 1.2, 1.3, 1.4)\n    ```\n    :::\n\n\n\n\n\n\n5.  Creamos una matriz `mat` de tamaño 2x2 a partir del vector `v`:\n\n\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    mat <- matrix(v, ncol = 2)\n    ```\n    :::\n\n\n\n\n\n\n    La matriz `mat` tiene 2 columnas y los elementos del vector `v` se llenan por columnas.\n\n6.  Creamos una lista `l` que contiene los elementos `a`, `dbl`, `chr` y `mat`:\n\n\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    l <- list(a, dbl, chr, mat)\n    ```\n    :::\n\n\n\n\n\n\n    La lista `l` contiene estos elementos en ese orden.\n\n7.  Finalmente, visualizamos el contenido de la lista en la consola:\n\n\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    l\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [[1]]\n    [1] 1\n    \n    [[2]]\n    [1] 0.500 0.600 0.250 1.200 0.333\n    \n    [[3]]\n    [1] \"a\" \"b\" \"c\"\n    \n    [[4]]\n         [,1] [,2]\n    [1,]  1.1  1.3\n    [2,]  1.2  1.4\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n\n\n    Esto imprime el contenido de la lista `l`.\n\n> Es importante comprender estas estructuras de datos en R, ya que nos permiten organizar y manipular la información de manera efectiva. Cada estructura tiene sus propias características y funciones asociadas que nos facilitan el trabajo con los datos en la programación.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}