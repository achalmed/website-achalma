{
  "hash": "c6b7597171f69f9b00729e09d4b98971",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Modelos Univariados y Multivariados de Volatilidad\nsubtitle: Modelos para analizar la volatilidad en series de tiempo.\ndescription: |\n  Introducción a modelos univariados y multivariados de volatilidad y su aplicación en series de tiempo\ncategories:\n  - Estadística\n  - Análisis de datos\n  - Series de tiempo\n  - Modelos Univariados\n  - Multivariados de Volatilidad\ntags:\n  - SeriesDeTiempo\n  - AnálisisDeDatos\n  - Estadística\n  - ModelosUnivariados\n  - MultivariadosDeVolatilidad\ndate: \"10/03/2023\"\ndraft: false  # Modo de borrador (false = final, true = borrador)\n---\n\n\n\n\n\n\n# Modelos Univariados y Multivariados de Volatilidad\n\n## Motivación\n\nEstos modelos de Heterocedásticidad Condicional Autoregresiva (ARCH, por sus siglas en inglés) y modelos Heterocedásticidad Condicional Autoregresiva Generalizados (GARCH, por sus siglas en inglés) tienen la característica de modelar situaciones como las que ilustra la Figutra \\@ref(fig:fig102). Es decir: \n\n1) Existen zonas donde la variación de los datos es mayor y zonas donde la variación es más estable--a estas situaciones se les conoce como de variabilidad por clúster--, y \n\n2) los datos corresponden a innformación de alta frecuencia.\n\nIniciemos por las bibliotecas necesarias:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(expm)\nlibrary(Matrix)\nlibrary(ggplot2)\nlibrary(quantmod)\nlibrary(moments)\nlibrary(dynlm)\nlibrary(broom)\nlibrary(FinTS)\nlibrary(lubridate)\nlibrary(forecast)\nlibrary(readxl)\nlibrary(MASS)\nlibrary(rugarch)\nlibrary(tsbox)\nlibrary(MTS)\nlibrary(rmgarch)\nlibrary(Rcpp)\n```\n:::\n\n\n\n\n\n\nPara el análisis de temas financieros existe una librería de mucha utilidad llamada __quantmod__. En primer lugar esta librería permite acceder a datos financieros de un modo muy simple, es posible decargar series financieras desde _yahoo_, la _FRED (Federal Reserve Economic Data)_, _google_, etc. Por otro lado también es una librería que permite realizar gráficos altamente estéticos con unas cuantas líneas de código. Ahora, usaremos datos de Yahoo Finance respecto de la cotización del bitcoin (ticker: \"BTC-USD\"). \n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\noptions(\"getSymbols.warning4.0\"=FALSE)\n\nBTC <-getSymbols(\"BTC-USD\", src = \"yahoo\", auto.assign = FALSE)\n\nBTC <- na.omit(BTC)\n\nchartSeries(BTC,TA='addBBands();\n                    addBBands(draw=\"p\");\n                    addVo();\n                    addMACD()',# subset='2021',\n                theme=\"white\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/Data_ARCH-1.png){width=672}\n:::\n\n```{.r .cell-code}\nhead(BTC)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           BTC-USD.Open BTC-USD.High BTC-USD.Low BTC-USD.Close BTC-USD.Volume\n2014-09-17      465.864      468.174     452.422       457.334       21056800\n2014-09-18      456.860      456.860     413.104       424.440       34483200\n2014-09-19      424.103      427.835     384.532       394.796       37919700\n2014-09-20      394.673      423.296     389.883       408.904       36863600\n2014-09-21      408.085      412.426     393.181       398.821       26580100\n2014-09-22      399.100      406.916     397.130       402.152       24127600\n           BTC-USD.Adjusted\n2014-09-17          457.334\n2014-09-18          424.440\n2014-09-19          394.796\n2014-09-20          408.904\n2014-09-21          398.821\n2014-09-22          402.152\n```\n\n\n:::\n\n```{.r .cell-code}\ntail(BTC)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           BTC-USD.Open BTC-USD.High BTC-USD.Low BTC-USD.Close BTC-USD.Volume\n2024-08-21     59014.99     61834.35    58823.45      61175.19    32731154072\n2024-08-22     61168.32     61408.11    59815.25      60381.91    27625734377\n2024-08-23     60380.95     64947.06    60372.05      64094.36    42530509233\n2024-08-24     64103.87     64513.79    63619.92      64178.99    21430585163\n2024-08-25     64176.37     64996.42    63833.52      64333.54    18827683555\n2024-08-26     64290.92     64403.72    63211.36      63808.71    26079922176\n           BTC-USD.Adjusted\n2024-08-21         61175.19\n2024-08-22         60381.91\n2024-08-23         64094.36\n2024-08-24         64178.99\n2024-08-25         64333.54\n2024-08-26         63808.71\n```\n\n\n:::\n:::\n\n\n\n\n\n\nPara fines del ejercicio de esta clase, usaremos el valor de la acción ajustado. Esto nos servirá para calcular el rendimiento diario, o puesto en lenguaje de series temporales podemos decir que usaremos la serie en diferencias logarítmicas. \n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplot(BTC$`BTC-USD.Adjusted`)\n```\n\n::: {.cell-output-display}\n![Evolución del precio del Bitcoin](index_files/figure-html/fig101-1.png){fig-align='center' width=672}\n:::\n:::\n\n\n\n\n\nUna de las preguntas relevantes al observar la serie en diferencias, es si podríamos afirmar que esta serie cumple con el supuesto de homoscedasticidad. \n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlogret <- ts(diff(log(BTC$`BTC-USD.Adjusted`))[-1])\n\nplot(logret)\n```\n\n::: {.cell-output-display}\n![Evolución del rendimiento (diferenccias logarítmicas) del Bitcoin](index_files/figure-html/fig102-1.png){fig-align='center' width=672}\n:::\n:::\n\n\n\n\n\n### Value at risk\n\nUtilicemos como ejemplo el Valor en Riesgo. Este es básicamente es un cálculo que nos permite estimar el monto que una acción o portafolio podría perder dada una probabilidad $(1-\\alpha)$. \n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nalpha <- 0.05\n\nVaR <- quantile( logret, alpha )\n\nround( VaR, 4 )*100\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   5% \n-5.89 \n```\n\n\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nqplot(logret , geom = 'histogram') + \n  geom_histogram(fill = 'lightblue' , bins = 30) +\n  geom_histogram( aes(logret[logret < quantile(logret , 0.05)]) , \n                  fill = 'red' , bins = 30) +\n  labs(x = 'Daily Returns')\n```\n\n::: {.cell-output-display}\n![Histograma de rendimientos del Bitcoin](index_files/figure-html/fig103-1.png){fig-align='center' width=672}\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnormal_dist <- rnorm(100000, mean(logret), sd(logret))\nVaR_n <- quantile(normal_dist, 0.05)\nES_n <- mean(normal_dist[normal_dist<VaR])\n  \nggplot()+\n  geom_density(aes(logret, geom ='density', col = 'returns'))+\n  geom_density(aes(normal_dist, col = 'normal'))\n```\n\n::: {.cell-output-display}\n![Densidad de rendimientos del Bitcoin Vs. una distribución normal](index_files/figure-html/fig104-1.png){fig-align='center' width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nvector_ret <- as.vector(logret)\n\n##Kurtosis\nround(kurtosis(vector_ret),2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 14.31\n```\n\n\n:::\n\n```{.r .cell-code}\n##Sesgo\nround(skewness(vector_ret),2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -0.73\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Prueba de normalidad \n\n$H_o: K=S=0$\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\njarque.test(vector_ret)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tJarque-Bera Normality Test\n\ndata:  vector_ret\nJB = 19669, p-value < 2.2e-16\nalternative hypothesis: greater\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Modelos ARCH y GARCH Univariados\n\nPara plantear el modelo supongamos --por simplicidad-- que hemos construido y estimado un modelo AR(1). Es decir, asumamos que el proceso subyacente para la media condicional está dada por:\n\\begin{equation}\n    X_t = a_0 + a_1 X_{t-1} + U_t\n\\end{equation}\n\nDonde $| a_1 |< 1$ para garantizar la convergencia del proceso en el largo plazo, en el cual:\n\\begin{eqnarray*}\n    \\mathbb{E}[X_t] & = & \\frac{a_0 }{1 - a_1} = \\mu \\\\\n    Var[X_t] & = & \\frac{\\sigma^2}{1 - a_1^2}\n\\end{eqnarray*}\n\nAhora, supongamos que este tipo de modelos pueden ser extendidos y generalizados a un modelo ARMA(p, q), que incluya otras variables exogénas. Denotemos a como $\\mathbf{Z}_t$ al conjunto que incluye los componentes AR, MA y variables exogénas que pueden explicar a $X_t$ de forma que el proceso estará dado por:\n\\begin{equation}\n    X_t = \\mathbf{Z}_t \\boldsymbol{\\beta} + U_t\n\\end{equation}\n\nDonde $U_t$ es un proceso estacionario que representa el error asociado a un proceso ARMA(p, q) y donde siguen diendo válidos los supuestos:\n\\begin{eqnarray*}\n    \\mathbb{E}[U_t] & = & 0 \\\\\n    Var[U_t^2] & = & \\sigma^2\n\\end{eqnarray*}\n\nNo obstante, en este caso podemos suponer que existe autocorrelación en el término de error al cuadrado que puede ser capturada por un porceso similar a uno de medias móviles (MA) dado por:\n\\begin{equation}\n    U_t^2 = \\gamma_0 + \\gamma_1 U_{t-1}^2 + \\gamma_2 U_{t-2}^2 + \\ldots + \\gamma_q U_{t-q}^2 + \\nu_t\n\\end{equation}\n\nDonde $\\nu_t$ es un ruido blanco y $U_{t-i} = X_{t-i} - \\mathbf{Z}_{t-i} \\boldsymbol{\\beta}$, $i = 1, 2 ,\\ldots $. Si bien los procesos son estacionarios por los supuestos antes enunciados, la varianza condicional estará dada por:\n\\begin{eqnarray*}\n    \\sigma^2_{t | t-1} & = & Var[ U_t | \\Omega_{t-1} ] \\\\\n    & = & \\mathbb{E}[ U^2_t | \\Omega_{t-1} ]\n\\end{eqnarray*}\n\nDonde $\\Omega_{t-1} = \\{U_{t-1}, U_{t-2}, \\ldots \\}$ es el conjunto de toda la información pasada de $U_t$ y observada hasta el momento $t-1$, por lo que:\n\\begin{equation*}\n    U_t | \\Omega_{t-1} \\sim \\mathbb{D}(0, \\sigma^2_{t | t-1})\n\\end{equation*}\n\nAsí, de forma similar a un proceso MA(q) podemos decir que la varianza condicional tendrá efectos ARCH de orden $q$ (ARCH(q)) cuando:\n\\begin{equation}\n    \\sigma^2_{t | t-1} = \\gamma_0 + \\gamma_1 U_{t-1}^2 + \\gamma_2 U_{t-2}^2 + \\ldots + \\gamma_q U_{t-q}^2\n    (\\#eq:ARCHEffect)\n\\end{equation}\n\nDonde $\\mathbb{E}[\\nu_t] = 0$ y $\\gamma_0$ y $\\gamma_i \\geq 0$, para $i = 1, 2, \\ldots, q-1$ y  $\\gamma_q > 0$. Estas condiciones son necesarias para garantizar que la varianza sea positiva. En general, la varianza condicional se expresa de la forma $\\sigma^2_{t | t-1}$, no obstante, para facilitar la notación, nos referiremos en cada caso a esta simplemente como $\\sigma^2_{t}$.\n\nPodemos generalizar está situación si asumimos a la varianza condicional como dependiente de lo valores de la varianza rezagados, es decir, como si fuera un proceso AR de orden $p$ para la varianza y juntandolo con la ecuación \\@ref(eq:ARCHEffect). Bollerslev (1986) y Taylor (1986) generalizaron el problema de heterocedásticidad condicional. El modelo se conoce como GARCH(p, q), el cual se especifica como:\n\\begin{eqnarray}\n    \\sigma^2_t & = & \\gamma_0 + \\gamma_1 U_{t-1}^2 + \\gamma_2 U_{t-2}^2 + \\ldots + \\gamma_q U_{t-q}^2 \\\\ \\nonumber \n    & & + \\beta_1 \\sigma^2_{t-1} + \\beta_2 \\sigma^2_{t-2} + \\ldots + \\beta_p \\sigma^2_{t-p}\n    (\\#eq:GARCHEffect)\n\\end{eqnarray}\n\nDonde las condiciones de no negatividad son que $\\gamma_0 > 0$, $\\gamma_i \\geq 0$, $i = 1, 2, \\ldots, q-1$, $\\beta_j \\geq 0$, $j = 1, 2, \\ldots, p-1$, $\\gamma_q > 0$ y $\\beta_p > 0$. Además, otra condición de convergencia es que:\n\\begin{equation*}\n    \\gamma_1 + \\ldots + \\gamma_q + \\beta_1 + \\ldots + \\beta_p < 1\n\\end{equation*}\n\nUsando el operador rezago $L$ en la ecuación \\@ref(eq:GARCHEffect) podemos obtener:\n\\begin{equation}\n    \\sigma^2_t = \\gamma_0 + \\alpha(L) U_t^2 + \\beta(L) \\sigma^2_t\n    (\\#eq:GARCHEffectL)\n\\end{equation}\n\nDe donde podemos establecer:\n\\begin{equation}\n    \\sigma^2_t = \\frac{\\gamma_0}{1 - \\beta(L)} + \\frac{\\alpha(L)}{1 - \\beta(L)} U_t^2 \n\\end{equation}\n\nPor lo que la ecuación \\@ref(eq:GARCHEffect) del GARCH(p, q) representa un ARCH($\\infty$):\n\\begin{equation}\n    \\sigma^2_t = \\frac{a_0}{1 - b_1 - b_2 - \\ldots - b_p} + \\sum_{i = 1}^\\infty U_{t-i}^2 \n\\end{equation}\n\n### Ejemplo ARCH(1) \n\nHasta ahora las distribuciones utilizadas para medir el Valor en Riesgo de este activo, asumen que no existe correlación serial en los retornos diarios de este activo. Observemos un par de gráficas de la función de autocorrelación para corroborar este hecho. \n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nacf(logret)\n```\n\n::: {.cell-output-display}\n![Función de autocorrelación parcial de lo rendimientos del Bitcoin](index_files/figure-html/fig105-1.png){fig-align='center' width=672}\n:::\n:::\n\n\n\n\n\n\nLa idea de clusterización de volatilidad, asume que periodos de alta volatilidad serán seguidos por una alta volatilidad y viceversa. Por esta razón la función de autocorrelación útil para saber si existen clústers de volatilidad es utilizando el valor absoluto, ya que lo que importa es saber si la serie está autocorrelacionada en la magnitud de los movimientos. \n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplot(abs(logret))\n```\n\n::: {.cell-output-display}\n![Evolución de los rendimientos del Bitcoin en valor absoluto](index_files/figure-html/fig106-1.png){fig-align='center' width=672}\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nacf(abs(logret))\n```\n\n::: {.cell-output-display}\n![Función de autocorrelación parcial de los rendimientos del Bitcoin en valor absoluto](index_files/figure-html/fig107-1.png){fig-align='center' width=672}\n:::\n:::\n\n\n\n\n\n\nOtra manera de corroborar esta idea es volviendo IID nuestra serie de datos y observar que de este modo se pierde la autocorrelación serial, lo que refuerza la idea de que en esta serie existen clusters de volatilidad. \n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlogret_random <- sample(as.vector(logret), size =  length(logret), replace = FALSE)\n\nacf(abs(logret_random))\n```\n\n::: {.cell-output-display}\n![Función de autocorrelación parcial de los rendimientos del Bitcoin en valor absoluto](index_files/figure-html/fig108-1.png){fig-align='center' width=672}\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npar(mfrow = c(1,2))\nplot(logret)\nplot(logret_random, type = 'l')\n```\n\n::: {.cell-output-display}\n![Función de autocorrelación parcial de los rendimientos del Bitcoin en valor absoluto](index_files/figure-html/fig109-1.png){fig-align='center' width=672}\n:::\n:::\n\n\n\n\n\n\nPrimer enfoque para comprobar aceptar o rechazar la hopótesis de que necesitamos estimar un ARCH(q)\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlogret_mean = dynlm(logret~1)\n\nsummary(logret_mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nTime series regression with \"ts\" data:\nStart = 1, End = 3631\n\nCall:\ndynlm(formula = logret ~ 1)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-0.46609 -0.01408 -0.00004  0.01554  0.22376 \n\nCoefficients:\n             Estimate Std. Error t value Pr(>|t|)  \n(Intercept) 0.0013600  0.0006106   2.227    0.026 *\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.03679 on 3630 degrees of freedom\n```\n\n\n:::\n\n```{.r .cell-code}\nehatsq = ts(resid(logret_mean)^2)\n\nARCH_m = dynlm(ehatsq~L(ehatsq))\n\nsummary(ARCH_m)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nTime series regression with \"ts\" data:\nStart = 2, End = 3631\n\nCall:\ndynlm(formula = ehatsq ~ L(ehatsq))\n\nResiduals:\n      Min        1Q    Median        3Q       Max \n-0.016832 -0.001178 -0.001046 -0.000329  0.216063 \n\nCoefficients:\n             Estimate Std. Error t value Pr(>|t|)    \n(Intercept) 1.177e-03  8.428e-05  13.969  < 2e-16 ***\nL(ehatsq)   1.291e-01  1.646e-02   7.843 5.73e-15 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.004897 on 3628 degrees of freedom\nMultiple R-squared:  0.01667,\tAdjusted R-squared:  0.0164 \nF-statistic: 61.52 on 1 and 3628 DF,  p-value: 5.73e-15\n```\n\n\n:::\n\n```{.r .cell-code}\nacf(ARCH_m$residuals)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/ArchTest-1.png){width=672}\n:::\n\n```{.r .cell-code}\nacf(abs(ARCH_m$residuals))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/ArchTest-2.png){width=672}\n:::\n\n```{.r .cell-code}\nArchTest(logret, lags = 1, demean = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tARCH LM-test; Null hypothesis: no ARCH effects\n\ndata:  logret\nChi-squared = 60.524, df = 1, p-value = 7.268e-15\n```\n\n\n:::\n:::\n\n\n\n\n\n\nEstimemos un ARCH(1), considerando la siguente especificación:\n\n$Y_t = \\mu+\\sqrt{h_t}\\varepsilon_t$\n\n$h_t = \\omega+\\alpha_ih_{t-i}+u_t$\n\n$\\varepsilon \\sim N(0,1)$\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rugarch)\n\nauto.arima(logret)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSeries: logret \nARIMA(2,0,0) with non-zero mean \n\nCoefficients:\n          ar1     ar2    mean\n      -0.0218  0.0112  0.0014\ns.e.   0.0166  0.0166  0.0006\n\nsigma^2 = 0.001354:  log likelihood = 6840.64\nAIC=-13673.28   AICc=-13673.27   BIC=-13648.49\n```\n\n\n:::\n\n```{.r .cell-code}\n#?ugarchspec\n\nmodel.spec = ugarchspec( variance.model = list(model = 'sGARCH' , \n                                               garchOrder = c(1, 0)), \n                        mean.model = list(armaOrder = c(2,0)), \n                        distribution.model = \"std\")\n\n#?ugarchfit\n\narch.fit = ugarchfit(spec = model.spec , data = logret, \n                     solver = 'solnp')\n\narch.fit@fit$matcoef\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           Estimate   Std. Error    t value     Pr(>|t|)\nmu      0.001587940 0.0003600610  4.4101985 1.032759e-05\nar1    -0.055305917 0.0163884214 -3.3746946 7.389766e-04\nar2    -0.002386500 0.0134210752 -0.1778174 8.588664e-01\nomega   0.002148213 0.0006025243  3.5653559 3.633628e-04\nalpha1  0.841582987 0.2724487466  3.0889589 2.008592e-03\nshape   2.306481180 0.1103316135 20.9049891 0.000000e+00\n```\n\n\n:::\n\n```{.r .cell-code}\nboot.garch <- ugarchboot(arch.fit,\n                         method = \"Partial\",\n                         sampling = \"raw\",  #bootstrap from fitted varepsilon\n                         n.ahead = 1,          #simulation horizon\n                         n.bootpred = 100000, #number of simulations \n                         solver = \"solnp\")\n\nboot.garch\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n*-----------------------------------*\n*     GARCH Bootstrap Forecast      *\n*-----------------------------------*\nModel : sGARCH\nn.ahead : 1\nBootstrap method:  partial\nDate (T[0]): 3631-01-01\n\nSeries (summary):\n         min      q.25     mean     q.75     max forecast[analytic]\nt+1 -0.47261 -0.010551 0.001735 0.015101 0.20422           0.002127\n.....................\n\nSigma (summary):\n         min    q0.25     mean    q0.75      max forecast[analytic]\nt+1 0.047201 0.047201 0.047201 0.047201 0.047201           0.047201\n.....................\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Ejemplo GARCH(0,1)\n\nEstimemos un GARCH(0,1) unsando la siguiente especificación:\n\n$Y_t = \\mu+\\sqrt{h_t}\\varepsilon_t$\n\n$h_t = \\omega+\\beta_i \\sigma^2_{t-i}+u_t$\n\n$\\varepsilon \\sim N(0,1)$\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel.spec = ugarchspec(variance.model = list(model = 'sGARCH' , \n                                              garchOrder = c(0,1)), \n                        mean.model = list(armaOrder = c(2,0)), \n                        distribution.model = \"std\")\n\nfit.garch.n = ugarchfit(spec = model.spec, data = logret, \n                        solver = \"solnp\")\n\nfit.garch.n@fit$matcoef\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           Estimate   Std. Error       t value     Pr(>|t|)\nmu     1.734371e-03 3.806907e-04     4.5558537 5.217324e-06\nar1   -6.449716e-02 1.395263e-02    -4.6225805 3.789957e-06\nar2   -5.254081e-03 1.334176e-02    -0.3938073 6.937233e-01\nomega  3.841413e-06 6.409382e-08    59.9342249 0.000000e+00\nbeta1  9.981935e-01 2.951312e-05 33822.0229359 0.000000e+00\nshape  2.494530e+00 2.729013e-02    91.4077848 0.000000e+00\n```\n\n\n:::\n\n```{.r .cell-code}\nboot.garch <- ugarchboot(fit.garch.n,\n                         method = \"Partial\",\n                         sampling = \"raw\",  #bootstrap from fitted varepsilon\n                         n.ahead = 1,          #simulation horizon\n                         n.bootpred = 100000, #number of simulations \n                         solver = \"solnp\")\nboot.garch\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n*-----------------------------------*\n*     GARCH Bootstrap Forecast      *\n*-----------------------------------*\nModel : sGARCH\nn.ahead : 1\nBootstrap method:  partial\nDate (T[0]): 3631-01-01\n\nSeries (summary):\n         min      q.25     mean     q.75     max forecast[analytic]\nt+1 -0.46638 -0.012854 0.001576 0.017389 0.24268           0.002371\n.....................\n\nSigma (summary):\n         min    q0.25     mean    q0.75      max forecast[analytic]\nt+1 0.046101 0.046101 0.046101 0.046101 0.046101           0.046101\n.....................\n```\n\n\n:::\n:::\n\n\n\n\n\n\n### Selección GARCH(p,q) óptimo\n\n¿Cómo seleccionamos el órden adecuado para un GARCH(p,q)? Acá una respuesta.\n\n$Y_t = \\mu+\\sqrt{h_t}\\varepsilon_t$\n\n$h_t = \\omega+\\beta_ih_{t-i}+\\alpha_i\\varepsilon^2_{t-i}+u_t$\n\n$\\varepsilon \\sim N(0,1)$\n\n#### Criterios de información \n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninfocriteria(fit.garch.n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                      \nAkaike       -4.065429\nBayes        -4.055188\nShibata      -4.065434\nHannan-Quinn -4.061781\n```\n\n\n:::\n:::\n\n\n\n\n\n\n#### Selección del modelo óptimo\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsource(\"code lag opt garch.r\")\n\nLag_Opt_GARCH(ehatsq,4,4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      q p       AIC Optimo\n [1,] 1 1 -10.90208      0\n [2,] 1 2 -10.90265      0\n [3,] 1 3 -10.90419      0\n [4,] 1 4 -10.90213      0\n [5,] 2 1 -10.90153      0\n [6,] 2 2 -10.90124      0\n [7,] 2 3 -10.90431      0\n [8,] 2 4 -10.90069      0\n [9,] 3 1 -10.90105      0\n[10,] 3 2 -10.90139      0\n[11,] 3 3 -10.90313      0\n[12,] 3 4 -10.90319      0\n[13,] 4 1 -10.90365      0\n[14,] 4 2 -10.90459      1\n[15,] 4 3 -10.90436      0\n[16,] 4 4 -10.90400      0\n```\n\n\n:::\n:::\n\n\n\n\n\n\n#### Estimación de modelo óptimo \n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel.spec = ugarchspec(variance.model = list(model = 'sGARCH', \n                                              garchOrder = c(4,2)), \n                        mean.model = list(armaOrder = c(2,0)), \n                        distribution.model = \"std\")\n\n\nmodel.fit = ugarchfit(spec = model.spec , data = logret, \n                      solver = 'solnp')\n\nmodel.fit@fit$matcoef\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n            Estimate   Std. Error       t value     Pr(>|t|)\nmu      1.305852e-03 3.255711e-04  4.010957e+00 6.047315e-05\nar1    -5.393541e-02 1.529745e-02 -3.525778e+00 4.222412e-04\nar2    -3.984444e-04 1.414304e-02 -2.817246e-02 9.775246e-01\nomega   2.590413e-05 5.504941e-06  4.705615e+00 2.531020e-06\nalpha1  1.351686e-01 2.275010e-02  5.941450e+00 2.825121e-09\nalpha2  2.532097e-07 3.379781e-02  7.491895e-06 9.999940e-01\nalpha3  9.384731e-08 2.768904e-02  3.389331e-06 9.999973e-01\nalpha4  2.556476e-02 2.261544e-02  1.130412e+00 2.583027e-01\nbeta1   4.274759e-01 2.095291e-01  2.040174e+00 4.133299e-02\nbeta2   4.107904e-01 1.650391e-01  2.489049e+00 1.280854e-02\nshape   3.175836e+00 1.281614e-01  2.477998e+01 0.000000e+00\n```\n\n\n:::\n\n```{.r .cell-code}\nboot.garch <- ugarchboot(model.fit,\n                         method = \"Partial\",\n                         sampling = \"raw\",  #bootstrap from fitted varepsilon\n                         n.ahead = 1,          #simulation horizon\n                         n.bootpred = 100000, #number of simulations \n                         solver = \"solnp\")\n\nboot.garch\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n*-----------------------------------*\n*     GARCH Bootstrap Forecast      *\n*-----------------------------------*\nModel : sGARCH\nn.ahead : 1\nBootstrap method:  partial\nDate (T[0]): 3631-01-01\n\nSeries (summary):\n         min      q.25     mean     q.75     max forecast[analytic]\nt+1 -0.38912 -0.011842 0.001784 0.016288 0.29799           0.001818\n.....................\n\nSigma (summary):\n         min    q0.25     mean    q0.75      max forecast[analytic]\nt+1 0.031325 0.031325 0.031325 0.031325 0.031325           0.031325\n.....................\n```\n\n\n:::\n:::\n\n\n\n\n\n\n#### Forecasting with GARCH(1,1)\n\nPara realizar pronósticos con la estimación de un GARCH, utilizando la librería _rugarch_, es necesario utilizar la función __ugarchforecast()__. \n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel.spec = ugarchspec(variance.model = list(model = 'sGARCH', \n                                              garchOrder = c(1,1)), \n                        mean.model = list(armaOrder = c(4,2)), \n                        distribution.model = \"std\")\n\nmodel.fit = ugarchfit(spec = model.spec , data = logret, \n                      solver = 'solnp')\n\nspec = getspec(model.fit)\n\nsetfixed(spec) <- as.list(coef(model.fit))\n```\n:::\n\n\n\n\n\n\nEsta función precisa como argumentos nuestra estimación del modelo GARCH, con una modificación en la manera en que se presentan los coeficientes, realizada en la última línea del código anterior y que llamamos _spec_. _n.ahead_ es el número de periodos que vamos a pronosticar, _n.roll_ señala el número de pronósticos móviles que utilizaremos, en caso de que haya más información para realizar el pronóstico. Finalmente damos como input nuestro set de datos y como producto obtendremos el pronostico de Sigma tanto como de la serie.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nforecast = ugarchforecast(spec, n.ahead = 12, n.roll = 0, logret)\n\nsigma(forecast)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     3631-01-01\nT+1  0.03119940\nT+2  0.03147465\nT+3  0.03174723\nT+4  0.03201723\nT+5  0.03228470\nT+6  0.03254971\nT+7  0.03281232\nT+8  0.03307259\nT+9  0.03333056\nT+10 0.03358630\nT+11 0.03383985\nT+12 0.03409127\n```\n\n\n:::\n\n```{.r .cell-code}\nfitted(forecast)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      3631-01-01\nT+1  0.002083136\nT+2  0.001029212\nT+3  0.001530259\nT+4  0.000985648\nT+5  0.001505265\nT+6  0.001037738\nT+7  0.001474274\nT+8  0.001082068\nT+9  0.001449586\nT+10 0.001120482\nT+11 0.001429972\nT+12 0.001153900\n```\n\n\n:::\n\n```{.r .cell-code}\nforecast\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n*------------------------------------*\n*       GARCH Model Forecast         *\n*------------------------------------*\nModel: sGARCH\nHorizon: 12\nRoll Steps: 0\nOut of Sample: 0\n\n0-roll forecast [T0=]:\n        Series   Sigma\nT+1  0.0020831 0.03120\nT+2  0.0010292 0.03147\nT+3  0.0015303 0.03175\nT+4  0.0009856 0.03202\nT+5  0.0015053 0.03228\nT+6  0.0010377 0.03255\nT+7  0.0014743 0.03281\nT+8  0.0010821 0.03307\nT+9  0.0014496 0.03333\nT+10 0.0011205 0.03359\nT+11 0.0014300 0.03384\nT+12 0.0011539 0.03409\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Modelos ARCH y GARCH Multivariados\n\nDe forma similar a los modelo univariados, los modelos multivariados de heterocedásticidad condicional asumen una estructura de la media condicional. En este caso, descrita por un VAR(p) cuyo proceso estocástico $\\mathbf{X}$ es estacionario de dimensión $k$. De esta forma la expresión reducida del modelo o el proceso VAR(p) estará dado por:\n\\begin{equation}\n    \\mathbf{X}_t = \\mathbf{\\delta} + A_1 \\mathbf{X}_{t-1} + A_2 \\mathbf{X}_{t-2} + \\ldots + A_p \\mathbf{X}_{t-p} + \\mathbf{U}_{t}\n\\end{equation}\n\nDonde cada uno de las $A_i$, $i = 1, 2, \\ldots, p$, son matrices cuadradas de dimensión $k$ y $\\mathbf{U}_t$ representa un vector de dimensión $k \\times 1$ con los residuales en el momento del tiempo $t$ que son un proceso pueramente aleatorio. También se incorpora un vector de términos constantes denominado como $\\mathbf{\\delta}$, el cual es de dimensión $k \\times 1$ --es este caso también es posible incorporar procesos determinas adicionales--.\n\nAsí, suponemos que el término de error tendrá estructura de vector:\n\\begin{equation*}\n    \\mathbf{U}_t = \n    \\begin{bmatrix}\n    U_{1t} \\\\ U_{2t} \\\\ \\vdots \\\\ U_{Kt}\n    \\end{bmatrix}\n\\end{equation*}\n\nDe forma que diremos que:\n\\begin{equation*}\n    \\mathbf{U}_t | \\Omega_{t-1} \\sim (0, \\Sigma_{t | t-1})\n\\end{equation*}\n\nDicho lo anterior, entonces, el mode ARCH(q) multivariado será descrito por:\n\\begin{equation}\n    Vech(\\Sigma_{t | t-1}) = \\boldsymbol{\\gamma}_0 + \\Gamma_1 Vech(\\mathbf{U}_{t-1} \\mathbf{U}_{t-1}') + \\ldots + \\Gamma_q Vech(\\mathbf{U}_{t-q} \\mathbf{U}_{t-q}')\n    (\\#eq:M_ARCH)\n\\end{equation}\n\nDonde $Vech$ es un operador que apila en un vector la parte superior de la matriz a la cual se le aplique, $\\boldsymbol{\\gamma}_0$ es un vector de cosntantes, $\\Gamma_i$, $i = 1, 2, \\ldots$ son matrices de coeficientes asociados a la estimación.\n\nPara ilustrar la ecuación \\@ref(eq:M_ARCH), tomemos un ejemplo de $K = 2$, de esta forma tenemos que un M-ARCH(1) será:\n\\begin{equation*}\n    \\Sigma_{t | t-1} = \n    \\begin{bmatrix}\n    \\sigma^2_{1, t | t-1} & \\sigma_{12, t | t-1} \\\\ \\sigma_{21, t | t-1} & \\sigma^2_{2, t | t-1}\n    \\end{bmatrix} = \n    \\begin{bmatrix}\n    \\sigma_{11, t} & \\sigma_{12, t} \\\\ \\sigma_{21, t} & \\sigma_{22, t}\n    \\end{bmatrix} =\n    \\Sigma_{t}\n\\end{equation*}\n\nDonde hemos simplificado la notación de la varianzas y la condición de que están en función de $t-1$. Así,\n\\begin{equation*}\n    Vech(\\Sigma_{t}) = \n    Vech \\begin{bmatrix}\n    \\sigma_{11, t} & \\sigma_{12, t} \\\\ \\sigma_{21, t} & \\sigma_{22, t}\n    \\end{bmatrix} =\n    \\begin{bmatrix}\n    \\sigma_{11, t} \\\\ \\sigma_{12, t} \\\\ \\sigma_{22, t}\n    \\end{bmatrix}\n\\end{equation*}\n\nDe esta forma, podemos establecer el modelo M-ARCH(1) con $K = 2$ será de la forma:\n\\begin{equation*}\n    \\begin{bmatrix}\n    \\sigma_{11, t} \\\\ \\sigma_{12, t} \\\\ \\sigma_{22, t}\n    \\end{bmatrix} =\n    \\begin{bmatrix}\n    \\gamma_{10} \\\\ \\gamma_{20} \\\\ \\gamma_{30}\n    \\end{bmatrix} +\n    \\begin{bmatrix}\n    \\gamma_{11} & \\gamma_{12} & \\gamma_{13} \\\\ \\gamma_{21} & \\gamma_{22} & \\gamma_{23} \\\\ \\gamma_{31} & \\gamma_{32} & \\gamma_{33}\n    \\end{bmatrix} \n    \\begin{bmatrix}\n    U^2_{1, t-1} \\\\ U_{1, t-1} U_{2, t-1} \\\\ U^2_{2, t-1}\n    \\end{bmatrix}\n\\end{equation*}\n\nComo notarán este tipo de procedimientos implica la estimación de muchos paramétros. En este circunstacia, se suelen estimar modelos restringidos para reducir el número de coeficientes estimados. por ejemplo, podríamos querer estimar un caso como:\n\\begin{equation*}\n    \\begin{bmatrix}\n    \\sigma_{11, t} \\\\ \\sigma_{12, t} \\\\ \\sigma_{22, t}\n    \\end{bmatrix} =\n    \\begin{bmatrix}\n    \\gamma_{10} \\\\ \\gamma_{20} \\\\ \\gamma_{30}\n    \\end{bmatrix} +\n    \\begin{bmatrix}\n    \\gamma_{11} & 0 & 0 \\\\ 0 & \\gamma_{22} & 0 \\\\ 0 & 0 & \\gamma_{33}\n    \\end{bmatrix} \n    \\begin{bmatrix}\n    U^2_{1, t-1} \\\\ U_{1, t-1} U_{2, t-1} \\\\ U^2_{2, t-1}\n    \\end{bmatrix}\n\\end{equation*}\n\nFinalmente y de forma analóga al caso univariado, podemos plantear un modelo M-GARCH(p, q) como:\n\\begin{equation}\n    Vech(\\Sigma_{t | t-1}) = \\boldsymbol{\\gamma}_0 + \\sum_{j = 1}^q \\Gamma_j Vech(\\mathbf{U}_{t-j} \\mathbf{U}_{t-j}') + \\sum_{m = 1}^p \\mathbf{G}_m Vech(\\Sigma_{t-m | t-m-1})\n    \\label{M_GARCH}\n\\end{equation}\n\nDonde cada una de las $\\mathbf{G}_m$ es una matriz de coeficientes. Para ilustrar este caso retomemos el ejemplo anterior pera ahora para un modelo M-GARCH(1, 1) con $K = 2$ de formaque tendríamos:\n\\begin{eqnarray*}\n    \\begin{bmatrix}\n    \\sigma_{11, t} \\\\ \\sigma_{12, t} \\\\ \\sigma_{22, t}\n    \\end{bmatrix} & = &\n    \\begin{bmatrix}\n    \\gamma_{10} \\\\ \\gamma_{20} \\\\ \\gamma_{30}\n    \\end{bmatrix} +\n    \\begin{bmatrix}\n    \\gamma_{11} & \\gamma_{12} & \\gamma_{13} \\\\ \\gamma_{21} & \\gamma_{22} & \\gamma_{23} \\\\ \\gamma_{31} & \\gamma_{32} & \\gamma_{33}\n    \\end{bmatrix} \n    \\begin{bmatrix}\n    U^2_{1, t-1} \\\\ U_{1, t-1} U_{2, t-1} \\\\ U^2_{2, t-1}\n    \\end{bmatrix} \\\\\n    & & + \n    \\begin{bmatrix}\n    g_{11} & g_{12} & g_{13} \\\\ g_{21} & g_{22} & g_{23} \\\\ g_{31} & g_{32} & g_{33}\n    \\end{bmatrix} \n    \\begin{bmatrix}\n    \\sigma_{11, t-1} \\\\ \\sigma_{12, t-1} \\\\ \\sigma_{22, t-1}\n    \\end{bmatrix}\n\\end{eqnarray*}\n\n## Pruebas para detectar efectos ARCH\n\nLa prueba que mostraremos es conocida como una ARCH-LM, la cual está basada en una regresión de los residuales estimados de un modelo VAR(p) o cualquier otra estimación que deseemos probar, con el objeto de determinar si existen efectos ARCH --esta prueba se puede simplificar para el caso univariado--.\n\nPartamos de platear:\n\\begin{eqnarray}\n    Vech(\\hat{\\mathbf{U}}_t \\hat{\\mathbf{U}}_t') & = & \\mathbf{B}_0 + \\mathbf{B}_1 Vech(\\hat{\\mathbf{U}}_{t-1} \\hat{\\mathbf{U}}_{t-1}') + \\ldots \\\\ \\nonumber\n    & & + \\mathbf{B}_q Vech(\\hat{\\mathbf{U}}_{t-q} \\hat{\\mathbf{U}}_{t-q}') + \\varepsilon_t\n    (\\#eq:ARCH-LM)\n\\end{eqnarray}\n\nDada la estimación en la ecuación \\@ref(eq:ARCH-LM), plantemos la estructura de hipótesis dada por:\n\\begin{eqnarray*}\n    H_0 & : & \\mathbf{B}_1 = \\mathbf{B}_2 = \\ldots = \\mathbf{B}_q = 0 \\\\\n    H_a & : & No H_0    \n\\end{eqnarray*}\n\nLa estadística de prueba será determinada por:\n\\begin{equation}\n    LM_{M-ARCH} = \\frac{1}{2} T K (K + 1) - Traza \\left( \\hat{\\Sigma}_{ARCH} \\hat{\\Sigma}^{-1}_{0} \\right) \\sim \\chi^2_{[q K^2 (K + 1)^2 / 4]}\n\\end{equation}\n\nDonde la matriz $\\hat{\\Sigma}_{ARCH}$ es calcula de acuerdo con la ecuación \\@ref(eq:ARCH-LM) y la matriz $\\hat{\\Sigma}_{0}$ sin considerar una estructura dada para los errores.\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}